<?php

namespace Stecman\Component\Symfony\Console\BashCompletion;

abstract class HookFactory
{
    /**
     * Hook scripts
     *
     * These are shell-specific scripts that pass required information from that shell's
     * completion system to the interface of the completion command in this module.
     *
     * The following placeholders are replaced with their value at runtime:
     *
     *     %%function_name%%      - name of the generated shell function run for completion
     *     %%program_name%%       - command name completion will be enabled for
     *     %%program_path%%       - path to program the completion is for/generated by
     *     %%completion_command%% - command to be run to compute completions
     *
     * NOTE: Comments are stripped out by HookFactory::stripComments as eval reads
     *       input as a single line, causing it to break if comments are included.
     *       While comments work using `... | source /dev/stdin`, existing installations
     *       are likely using eval as it's been part of the instructions for a while.
     *
     * @var array
     */

    /**
     * Return a completion hook for the specified shell type
     *
     * @param string $programPath
     * @param string $programName
     * @param bool   $multiple
     *
     * @return string
     */
    public function generateHook($programPath, $programName = null, $multiple = false)
    {
        // Use the program path if an alias/name is not given
        $programName = $programName ?: $programPath;

        $completionCommand = $multiple ? '$1 _completion' : $programPath . ' _completion';

        // Pass shell type during completion so output can be encoded if the shell requires it
        $completionCommand .= " --shell-type {$this->getShell()}";

        return str_replace(
            array(
                '%%function_name%%',
                '%%program_name%%',
                '%%program_path%%',
                '%%completion_command%%',
            ),
            array(
                $this->generateFunctionName($programPath, $programName),
                $programName,
                $programPath,
                $completionCommand,
            ),
            $this->getScript()
        );
    }

    /**
     * Escape each completion result for the specified shell. No transformation by default.
     *
     * @param string            $result  Completion results that should appear in the shell
     * @param CompletionContext $context Completion context
     *
     * @return string
     */
    public function escape($result, $context)
    {
        return $result;
    }

    /**
     * Retrieves the shell type
     *
     * @return mixed
     */
    abstract public function getShell();

    /**
     * Retrieves the script
     *
     * @return string
     */
    abstract public function getScript();

    /**
     * Generate a function name that is unlikely to conflict with other generated function names in the same shell
     *
     * @param string $programPath
     * @param string $programName
     *
     * @return string
     */
    protected function generateFunctionName($programPath, $programName)
    {
        return sprintf(
            '_%s_%s_complete',
            $this->sanitiseForFunctionName(basename($programName)),
            substr(md5($programPath), 0, 16)
        );
    }

    /**
     * Make a string safe for use as a shell function name
     *
     * @param string $name
     *
     * @return string
     */
    protected function sanitiseForFunctionName($name)
    {
        $name = str_replace('-', '_', $name);

        return preg_replace('/\W+/', '', $name);
    }

    /**
     * Strip '#' style comments from a string
     *
     * BASH's eval doesn't work with comments as it removes line breaks, so comments have to be stripped out
     * for this method of sourcing the hook to work. Eval seems to be the most reliable method of getting a
     * hook into a shell, so while it would be nice to render comments, this stripping is required for now.
     *
     * @param string $script
     *
     * @return string
     */
    protected function stripComments($script)
    {
        return preg_replace('/(^\s*#.*$)/m', '', $script);
    }
}
